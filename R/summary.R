#' Print summary of parameter tests.
#'
#' \code{summary.paramtest} calculates a summary of a given variable across all,
#' or a portion of, the parameter tests.
#'
#' @param object A list of class 'paramtest' generated by the function
#'   \code{run_test}.
#' @param outcome A string with the variable name across which to generate the
#'   summaries.
#' @param params If NULL, the function will return a summary across all
#'   generated test parameters. A character vector can also be included
#'   here, in which case the function will return summaries for only the
#'   selected parameter names. Finally, users can input a list, with the names
#'   of the elements corresponding to parameter names, and the values of each
#'   element providing a vector with the parameter values to be included in the
#'   summary. In all cases, the summary will collapse across all parameters or
#'   parameter values that are excluded from \code{params}.
#' @param func The function to be used to generate the summary (e.g., mean, sum).
#' @param ... Any other arguments to be passed to func.
#' @return Returns a data frame with one row per set of unique tests.
#' @seealso \code{\link{run_test}}
#' @examples
#' lm_test <- function(iter, N, b0, b1) {
#'     x <- rnorm(N, 0, 1)
#'     y <- rnorm(N, b0 + b1*x, sqrt(1 - b1^2))
#'     data <- data.frame(y, x)
#'     model <- lm(y ~ x, data)
#'
#'     # capture output from model summary
#'     est <- coef(summary(model))['x', 'Estimate']
#'     se <- coef(summary(model))['x', 'Std. Error']
#'     p <- coef(summary(model))['x', 'Pr(>|t|)']
#'
#'     return(c(xm=mean(x), xsd=sd(x), ym=mean(y), ysd=sd(y), est=est, se=se, p=p,
#'         sig=est > 0 & p <= .05))
#' }
#'
#' # test power for sample sizes between N=200 and N=300, with 5000 iterations total
#' power_sim <- random_search(lm_test, params=list(N=c(200, 300)), n.iter=5000, b0=0, b1=.15)
#'
#' # will calculate the mean for all 'sig' values in all tests where N=200,
#' # and all tests where N=300
#' summary(power_sim, 'sig', params=list(N=c(200, 300)))
#' @export
summary.paramtest <- function(object, outcome, params=NULL, func=mean, ...) {
    if (is.null(params)) {
        grid <- object$tests
    } else if (is.list(params)) {
        paramNames <- names(params)
        grid <- object$tests

        # it is assumed that each list element has a vector with the values to
        # be included for that parameter; so we loop through each parameter and
        # pare down the grid to only include those values
        for (p in 1:length(params)) {
            grid <- grid[grid[, paramNames[p]] %in% params[[p]], , drop=FALSE]
        }

        grid <- unique(grid[, paramNames, drop=FALSE])
    } else if (is.vector(params)) {
        grid <- unique(object$tests[, params, drop=FALSE])
    }

    if (nrow(grid) > 0) {
        results <- grid
        # loop through each combination of tests
        for (i in 1:nrow(grid)) {
            data <- object$results

            # loop through each parameter value individually and filter down data
            for (p in 1:ncol(grid)) {
                paramName <- paste0(names(object$tests)[p], '.test')
                data <- data[data[, paramName] == object$tests[i, p], ]
            }

            results[i, as.character(substitute(func))] <- func(data[, outcome], ...)
        }
    } else {
        results <- func(object$results[, outcome], ...)
    }
    return(results)
}


