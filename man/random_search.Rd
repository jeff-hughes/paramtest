% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/search_funcs.R
\name{random_search}
\alias{random_search}
\title{Run a function iteratively using a random search approach for parameter
values, with options for parallel processing.}
\usage{
random_search(func, params = NULL, n.sample = 1, n.iter = 1,
  output = c("list", "data.frame"), boot = FALSE, bootParams = NULL,
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL,
  beep = NULL, ...)
}
\arguments{
\item{func}{A user-defined function. The first argument to this function will
be the iteration number.}

\item{params}{A named list of parameters to be passed to \code{func}. For
continuous numeric values, a parameter must provide a two-element named
vector with names "lower" and "upper" to specify the lower and upper bounds
within which to sample. For parameters with integer values, provide a
sequence, e.g., \code{seq(5, 10)}. For parameters with non-numeric values,
provide a vector with the values from which to sample. On each iteration,
the \code{random_search} function will select a uniformly random value
for each parameter and pass this set of parameter values to \code{func}.}

\item{n.sample}{Number of times to sample from the parameter values.}

\item{n.iter}{Number of iterations (per set of params).}

\item{output}{Specifies how \code{random_search} provides the ultimate output
from \code{func}: can return a "list" or a "data.frame". Note that if
"data.frame" is specified, the supplied function must return a vector,
matrix, or data frame, so it can be coerced into the data frame format. The
"list" option will accept any type of output.}

\item{boot}{Whether or not to use bootstrapped data to pass along to
\code{func}. Using this option instead of bootstrapping within \code{func}
is preferable to take advantage of parallelization.}

\item{bootParams}{If \code{boot=TRUE}, then use \code{bootParams} to pass
along a named list of arguments to the \code{\link{boot}} function. The
statistic and R parameters will be filled automatically, but at minimum you
will need to pass along data. Information about parallel processing will
also be passed along automatically.}

\item{parallel}{The type of parallel operation to be used (if any).}

\item{ncpus}{Integer: the number of processes to be used in parallel
operation.}

\item{cl}{An optional \code{parallel} or \code{snow} cluster for use if
\code{parallel = 'snow'}. If not supplied, a cluster on the local machine
is created for the duration of the iterations.}

\item{beep}{Include a numeric value or character vector indicating the sound
you wish to play once the tests are done running. Requires the "beepr"
package, and information about supported values is available in the
documentation for that package.}

\item{...}{Additional arguments to be passed to \code{func}. If you do not
need to vary certain parameters in your model, you can pass them to
\code{func} here.}
}
\value{
Returns a list (by default) with one element per iteration. If
  \code{output} is specified as "dataframe", then \code{func} must
  return a (named) vector with the results you wish to capture; if
  \code{output} is specified as "vector", then \code{func} must return a
  one-element vector.
}
\description{
\code{random_search} runs a user-defined function iteratively. Lower and
upper bounds for parameter values can be given to \code{random_search}, which
will then (uniformly) randomly select values within those bounds on each
iteration.
}
\examples{
lm_test <- function(iter, N, b0, b1) {
    x <- rnorm(N, 0, 1)
    y <- rnorm(N, b0 + b1*x, sqrt(1 - b1^2))
    data <- data.frame(y, x)
    model <- lm(y ~ x, data)

    # capture output from model summary
    est <- coef(summary(model))['x', 'Estimate']
    se <- coef(summary(model))['x', 'Std. Error']
    p <- coef(summary(model))['x', 'Pr(>|t|)']

    return(c(xm=mean(x), xsd=sd(x), ym=mean(y), ysd=sd(y), est=est, se=se, p=p,
        sig=est > 0 & p <= .05))
}

# test power for sample sizes between N=200 and N=300, with 5000 iterations total
power_sim <- random_search(lm_test, params=list(N=c(200, 300)), n.iter=5000, b0=0, b1=.15)
}
\seealso{
\code{\link{boot}}
}

