% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/search_funcs.R
\name{grid_search}
\alias{grid_search}
\title{Run a function iteratively using a grid search approach for parameter values,
with options for parallel processing.}
\usage{
grid_search(func, params = NULL, n.iter = 1, output = c("list",
  "data.frame", "vector"), boot = FALSE, bootParams = NULL,
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL,
  beep = NULL, ...)
}
\arguments{
\item{func}{A user-defined function. The first argument to this function will
be the iteration number.}

\item{params}{A list of parameters to be passed to \code{func}. The
parameters are fully crossed so that each parameter value is tested at all
other values of all parameters. (For example, list(N=c(5, 10), x=c(1, 2))
will test four sets of parameters: N=5 and x=1, N=5 and x=2, N=10 and x=1,
and N=10 and x=2.) Each set of parameters will then be passed to
\code{func} in turn.}

\item{n.iter}{Number of iterations (per set of params).}

\item{output}{Specifies how \code{grid_search} provides the ultimate output
from func: can return a "list", a "data.frame", or a "vector". Note that
the output from the supplied function must be able to be coerced into this
output type.}

\item{boot}{Whether or not to use bootstrapped data to pass along to
\code{func}. Using this option instead of bootstrapping within \code{func}
is preferable to take advantage of parallelization.}

\item{bootParams}{If \code{boot=TRUE}, then use \code{bootParams} to pass
along a named list of arguments to the \code{\link{boot}} function. The
statistic and R parameters will be filled automatically, but at minimum you
will need to pass along data. Information about parallel processing will
also be passed along automatically.}

\item{parallel}{The type of parallel operation to be used (if any).}

\item{ncpus}{Integer: the number of processes to be used in parallel
operation.}

\item{cl}{An optional \code{parallel} or \code{snow} cluster for use if
\code{parallel = 'snow'}. If not supplied, a cluster on the local machine
is created for the duration of the iterations.}

\item{beep}{Include a numeric value or character vector indicating the sound
you wish to play once the tests are done running. Requires the "beepr"
package, and information about supported values is available in the
documentation for that package.}

\item{...}{Additional arguments to be passed to \code{func}. If you do not
need to vary certain parameters in your model, you can pass them to
\code{func} here.}
}
\value{
Returns a list (by default) with one element per iteration. If
  \code{output} is specified as "dataframe", then \code{func} must
  return a (named) vector with the results you wish to capture; if
  \code{output} is specified as "vector", then \code{func} must return a
  one-element vector.
}
\description{
\code{grid_search} runs a user-defined function iteratively. Parameter values
can be given to \code{grid_search}, which will fully cross all parameters so
that each parameter value is tested at all other values of all parameters.
}
\examples{
lm_test <- function(iter, N, b0, b1) {
    x <- rnorm(N, 0, 1)
    y <- rnorm(N, b0 + b1*x, sqrt(1 - b1^2))
    data <- data.frame(y, x)
    model <- lm(y ~ x, data)

    # capture output from model summary
    est <- coef(summary(model))['x', 'Estimate']
    se <- coef(summary(model))['x', 'Std. Error']
    p <- coef(summary(model))['x', 'Pr(>|t|)']

    return(c(xm=mean(x), xsd=sd(x), ym=mean(y), ysd=sd(y), est=est, se=se, p=p,
        sig=est > 0 & p <= .05))
}

# test power for sample size N=200 and N=300, with 5000 iterations for each
power_sim <- grid_search(lm_test, params=list(N=c(200, 300)), n.iter=5000, b0=0, b1=.15)
}
\seealso{
\code{\link{boot}}
}

